{
	"Competetive Programming Template": {
		"prefix": "temp",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"using ll = long long;",
			"using ull = unsigned long long;",
			"const int MOD = 1e9 + 7;",
			"const double eps = 1e-9;",
			"#define all(x) begin(x), end(x)",
			"#define sor(x) sort(all(x))",
			"#define rev(x) reverse(all(x))",
			"// For a problem try to generate a idea then try to \"DISPROVE\" the idea",
			"// While disproving you might get another idea , so repeat",
			"",
			"void __print(int x) {cerr << x;}",
			"void __print(long x) {cerr << x;}",
			"void __print(long long x) {cerr << x;}",
			"void __print(unsigned x) {cerr << x;}",
			"void __print(unsigned long x) {cerr << x;}",
			"void __print(unsigned long long x) {cerr << x;}",
			"void __print(float x) {cerr << x;}",
			"void __print(double x) {cerr << x;}",
			"void __print(long double x) {cerr << x;}",
			"void __print(char x) {cerr << '\\'' << x << '\\'';}",
			"void __print(const char *x) {cerr << '\"' << x << '\"';}",
			"void __print(const string &x) {cerr << '\"' << x << '\"';}",
			"void __print(bool x) {cerr << (x ? \"true\" : \"false\");}",
			"",
			"template<typename T, typename V>",
			"void __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}",
			"template<typename T>",
			"void __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \",\" : \"\"), __print(i); cerr << \"}\";}",
			"void _print() {cerr << \"]\\n\";}",
			"template <typename T, typename... V>",
			"void _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}",
			"#ifndef ONLINE_JUDGE",
			"#define debug(x...) cerr << \"[\" << #x << \"] = [\"; _print(x);",
			"#else",
			"#define debug(x...);",
			"#endif",
			"template<typename T> ostream& operator+(ostream& o, const vector<T> &v){for(const auto &x : v){o<<x<<\" \";}o<<\"\\n\";return o;}",
			"template<typename T> ostream& operator*(ostream& o, const vector<T> &v){for(const auto &x : v){o+x;}return o;}",
			"template<typename T> istream& operator>>(istream& i, vector<T> &v){for(auto &x : v){i>>x;}return i;}",
			"",
			"int main()",
			"{",
			"\tios_base::sync_with_stdio(false);",
			"\tcin.tie(NULL);",
			"\tcout.tie(NULL);",
			"",
			"\tint TC;",
			"\tcin >> TC;",
			"\tfor(int tc=1; tc <= TC; tc++)",
			"\t{",
			"\t\t",
			"\t}",
			"",
			"\treturn 0;",
			"}"
		],
		"description": "Template for cp"
	},
	"Atcoder Competetive Programming Template": {
		"prefix": "atcoder",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"using ll = long long;",
			"using ull = unsigned long long;",
			"const int MOD = 1e9 + 7;",
			"#define all(x) begin(x), end(x)",
			"#define sor(x) sort(all(x))",
			"#define rev(x) reverse(all(x))",
			"// For a problem try to generate a idea then try to \"DISPROVE\" the idea",
			"// While disproving you might get another idea , so repeat",
			"",
			"void __print(int x) {cerr << x;}",
			"void __print(long x) {cerr << x;}",
			"void __print(long long x) {cerr << x;}",
			"void __print(unsigned x) {cerr << x;}",
			"void __print(unsigned long x) {cerr << x;}",
			"void __print(unsigned long long x) {cerr << x;}",
			"void __print(float x) {cerr << x;}",
			"void __print(double x) {cerr << x;}",
			"void __print(long double x) {cerr << x;}",
			"void __print(char x) {cerr << '\\'' << x << '\\'';}",
			"void __print(const char *x) {cerr << '\"' << x << '\"';}",
			"void __print(const string &x) {cerr << '\"' << x << '\"';}",
			"void __print(bool x) {cerr << (x ? \"true\" : \"false\");}",
			"",
			"template<typename T, typename V>",
			"void __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}",
			"template<typename T>",
			"void __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \",\" : \"\"), __print(i); cerr << \"}\";}",
			"void _print() {cerr << \"]\\n\";}",
			"template <typename T, typename... V>",
			"void _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}",
			"#ifndef ONLINE_JUDGE",
			"#define debug(x...) cerr << \"[\" << #x << \"] = [\"; _print(x)",
			"#else",
			"#define debug(x...)",
			"#endif",
			"template<typename T> ostream& operator+(ostream& o, const vector<T> &v){for(const auto &x : v){o<<x<<\" \";}o<<\"\\n\";return o;}",
			"template<typename T> ostream& operator*(ostream& o, const vector<T> &v){for(const auto &x : v){o+x;}return o;}",
			"template<typename T> istream& operator>>(istream& i, vector<T> &v){for(auto &x : v){i>>x;}return i;}",
			"",
			"int main()",
			"{",
			"\t",
			"\t",
			"\treturn 0;",
			"}"
		],
		"description": "Template for cp"
	},
	"File input/output": {
		"prefix": "fileio",
		"body": [
			"void fileio(string filename) {",
			"    freopen((filename + \".in\").c_str(), \"r\", stdin);",
			"    freopen((filename + \".out\").c_str(), \"w\", stdout);",
			"}"
		],
		"description": "File input/output"
	},
	"Binary Exponention": {
		"prefix": "binexp",
		"body": [
			"long long binexp(long long a, long long n)",
			"{",
			"\tlong long ans = 1;",
			"\twhile(n > 0)",
			"\t{",
			"\t\tif(n & 1)",
			"\t\t\tans = (ans * a) % MOD;",
			"\t\ta = (a * a) % MOD;",
			"\t\tn >>= 1;",
			"\t}",
			"\treturn ans;",
			"}",
		],
		"description": "Iterative method of binary exponention for fast exponention calculation."
	},
	"Binary Multiplication": {
		"prefix": "binmul",
		"body": [
			"long long binmul(long long a, long long b)",
			"{",
			"\tlong long ans = 1;",
			"\twhile(b > 0)",
			"\t{",
			"\t\tif(b & 1)",
			"\t\t\tans = (ans + a) % MOD;",
			"\t\ta = (a + a) % MOD;",
			"\t\tb >>= 1;",
			"\t}",
			"\treturn ans;",
			"}",
		],
		"description": "Iterative method of binary multiplication for large modded multiplication calculation."
	},
	"Sieve": {
		"prefix": "sieve",
		"body": [
			"const int N = 1e7 + 10;",
			"vector<bool> isPrime(N, true);",
			"void sieve()",
			"{",
			"\tisPrime[0] = isPrime[1] = false;",
			"\tfor (int i = 2; i < N; i++)",
			"\t{",
			"\t\tif(isPrime[i])",
			"\t\t{",
			"\t\t\tfor (int j = 2 * i; j < N; j += i)",
			"\t\t\t{",
			"\t\t\t\tisPrime[j] = false;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"}",
		],
		"description": "Prime factorization of a number with sieve."
	},
	"SieveWithLowestAndHighestPrimes": {
		"prefix": "sievehlp",
		"body": [
			"const int N = 1e7 + 10;",
			"vector<bool> isPrime(N, true);",
			"vector<int> lp(N, 0), hp(N, 0);",
			"void sieve()",
			"{",
			"\tisPrime[0] = isPrime[1] = false;",
			"\tfor (int i = 2; i < N; i++)",
			"\t{",
			"\t\tif(isPrime[i])",
			"\t\t{",
			"\t\t\tlp[i] = hp[i] = i;",
			"\t\t\tfor (int j = 2 * i; j < N; j += i)",
			"\t\t\t{",
			"\t\t\t\tisPrime[j] = false;",
			"\t\t\t\thp[j] = i;",
			"\t\t\t\tif(lp[j] == 0) lp[j] = i;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"}",
		],
		"description": "Prime factorization of a number with sieve.(With lowest and highest primes)"
	},
	"Prime factorisation of the given number in a vector. This is uses highest and lowest factors from seive to calculate in O(1). Use this if number is smaller and test case count is larger. Complexity : O(N + T) = O(N) or O(T)": {
		"prefix": "primefactorsvector",
		"body": [
			"void primeFactors(int num, vector<int> &primeFactors)",
			"{",
			"    while(num > 1)",
			"    {",
			"        int primeFactor = lp[num];",
			"        while(num % primeFactor == 0)",
			"        {",
			"            primeFactors.push_back(primeFactor);",
			"            num /= primeFactor;",
			"        }",
			"    }",
			"}"
		],
		"description": "Prime factorisation of the given number in a vector. This is uses highest and lowest factors from seive to calculate in O(1). Use this if number is smaller and test case count is larger. Complexity : O(N + T) = O(N) or O(T)"
	},
	"Prime factorisation of the given number in a map. This is uses highest and lowest factors from seive to calculate in O(1). Use this if number is smaller and test case count is larger. Complexity : O(N + T) = O(N) or O(T)": {
		"prefix": "primefactorsmap",
		"body": [
			"void primeFactors(int num, map<int, int> &primeFactors)",
			"{",
			"    while(num > 1)",
			"    {",
			"        int primeFactor = lp[num];",
			"        while(num % primeFactor == 0)",
			"        {",
			"            primeFactors[primeFactor]++;",
			"            num /= primeFactor;",
			"        }",
			"    }",
			"}"
		],
		"description": "Prime factorisation of the given number in a map. This is uses highest and lowest factors from seive to calculate in O(1). Use this if number is smaller and test case count is larger. Complexity : O(N + T) = O(N) or O(T)"
	},
	"Prime factorisation of the given number in a map. This is the square root of n method. Use this if number is larger and test case count is small. Complexity : O(sqrt(N) * T)": {
		"prefix": "primesqrt",
		"body": [
			"void primeFactors(int num, map<int, int> &primeFactors)",
			"{",
			"    for (int i = 2; i * i <= num; i++)",
			"    {",
			"        while (num % i == 0)",
			"        {",
			"            primeFactors[i]++;",
			"            num /= i;",
			"        }",
			"    }",
			"    if(num > 1) primeFactors[num]++;",
			"}"
		],
		"description": "Prime factorisation of the given number in a map. This is the square root of n method. Use this if number is larger and test case count is small. Complexity : O(sqrt(N) * T)"
	},
	"Get a single bit from a number.": {
		"prefix": "getbit",
		"body": [
			"bool get_bit(int64_t a,int i)",
			"{",
			"    return a&(1ll<<i);",
			"}"
		],
		"description": "Returns bit at position i of a number."
	},
	// "Converts a number to its binary represantation." :
	// {
	// 	"prefix": "toBinary",
	// 	"body": [
	// 		""
	// 	],
	// 	"description": "Returns a vector containing binary represensation of the passed number."
	// },
	"Yes or No answer printing.": {
		"prefix": "yesno",
		"body": [
			"if($1) cout << \"YES\" << endl;",
			"else cout << \"NO\" << endl;",
			""
		],
		"description": "Yes or No answer printing."
	},
	"DSU by size.": {
		"prefix": "dsu",
		"body": [
			"void make_set(int v) {",
			"    parent[v] = v;",
			"    size[v] = 1;",
			"}",
			"",
			"void union_sets(int a, int b) {",
			"    a = find_set(a);",
			"    b = find_set(b);",
			"    if (a != b) {",
			"        if (size[a] < size[b])",
			"            swap(a, b);",
			"        parent[b] = a;",
			"        size[a] += size[b];",
			"    }",
			"}",
			"",
			"int find_set(int v) {",
			"    if (v == parent[v])",
			"        return v;",
			"    return parent[v] = find_set(parent[v]);",
			"}",
		],
		"description": "Disjoint set union optimised using size. Look CP algorithm."
	},
	"Board moves.": {
		"prefix": "board",
		"body": [
			"int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};",
			"bool valid(int board_x, int board_y, int board_N, int board_M) {",
			"return board_x >= 0 && board_y < board_N && y >= 0 && y < board_M;",
			"}",
		],
		"description": "Board neighbour moves and validity checker."
	},
	"2D Prefix Sum": {
		"prefix": "prefsum2d",
		"body": [
			"vector<vector<ll>> pref(n + 1, vector<ll>(m + 1, 0));",
			"for (int i = 1; i <= n; i++)",
			"{",
			"    for (int j = 1; j <= m; j++)",
			"    {",
			"        pref[i][j] = arr[i - 1][j - 1] + pref[i - 1][j] + pref[i][j - 1] - pref[i - 1][j - 1];",
			"    }",
			"}",
			"// To use - sum between (i, j) and (i + k, j + k)",
			"// pref[i + k][j + k] - pref[i][j + k] - pref[i + k][j] + pref[i][j]",
		],
		"description": "Code for 2d prefix sum. (becaredful 1-based)."
	},
	"DFS": {
		"prefix": "dfs",
		"body": [
			"int n; // number of vertices",
			"vector<vector<int>> adj; // graph represented as an adjacency list",
			"vector<int> tin, tout, color;",
			"int dfs_timer = 0;",
			"",
			"void dfs(int v) ",
			"{",
			"    tin[v] = dfs_timer++;",
			"    color[v] = 1;",
			"    for (int to : adj[v])",
			"    {",
			"        if (color[to] == 0)",
			"        {",
			"            dfs(to);",
			"        }",
			"    }",
			"    color[v] = 2;",
			"    tout[v] = dfs_timer++;",
			"}",
		]
	},
	"Bridge Detection": {
		"prefix": "bridge detection",
		"body": [
			"int n;",
			"vector<vector<int>> adj;",
			"vector<bool> vis;",
			"vector<int> tin, low;",
			"int dfs_timer = 0;",
			"vector<pair<int, int>> bridges;",
			"",
			"void dfs(int v, int p = -1)",
			"{",
			"    vis[v] = true;",
			"    tin[v] = low[v] = dfs_timer++;",
			"    bool parent_skipped = false;",
			"",
			"    for (int to : adj[v])",
			"    {",
			"        if (to == p && !parent_skipped) // if parent skipped once dont ignore anymore (multiple edge)",
			"        {",
			"            parent_skipped = true;",
			"            continue;",
			"        }",
			"",
			"        if (vis[to]) // (v, to) is a back-edge, only see tin[to]",
			"        {",
			"            low[v] = min(low[v], tin[to]);",
			"        }",
			"        else",
			"        {",
			"            dfs(to, v);",
			"            low[v] = min(low[v], low[to]);",
			"",
			"            // If low[to] > tin[u], meaning 'to' can't reach u through any back edge, then (v, to) is bridge because (v, to) can isolate to.",
			"            if (low[to] > tin[v])",
			"                bridges.push_back({v, to});",
			"        }",
			"    }",
			"}",
		],
		"description": "Finding bridge using tarzan algorithm in O(N + M) using DFS's time of insertion."
	},
	"Ordered Set (Boost)": {
		"prefix": "orderedset",
		"body": 
		[
			"#include <ext/pb_ds/assoc_container.hpp>",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"using namespace __gnu_pbds;",
			"template <typename T>",
			"using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
			"",
			"ordered_set<int> st;",
			"int position = s.order_of_key(2); // the number of elements in the s less than 2",
			"int value = *s.find_by_order(0);  // print the 0-th smallest number in s(0-based)",
		],
		"description": "C++ STL set uses red-black tree which cannot find the position/order of element in logn time. Use this sgi stl tree to find a value in logarithmic time. Use order_of_key to find position of value you want to find.",
	},
	"Safe Unordered Map":{
		"prefix": "customhash-unorderedmap",
		"body":[
			"struct custom_hash {",
			"    static uint64_t splitmix64(uint64_t x) {",
            "        x += 0x9e3779b97f4a7c15;",
            "        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
            "        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
            "        return x ^ (x >> 31);",
            "    }",
            "",
            "    size_t operator()(uint64_t x) const {",
            "        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
            "        return splitmix64(x + FIXED_RANDOM);",
            "    }",
			"};",
			"",
			"unordered_map<long long, int, custom_hash> safe_map;",
		],
		"description": "Custom Hash Function of C++ is pretty predictable and prone to fail in hacking phase. So this randomised hash function is pretty good for targeted values rather than random.",
	},
	"Binary Conversions":{
		"prefix": "toBinary",
		"body":[
			"vector<int> toBinary(unsigned long long num)",
			"{",
			"\tvector<int> arr(64, 0);",
			"\tull mask = 1;",
			"\tfor (int i = 0; i < 64; i++)",
			"\t\tif(num & (mask << i)) arr[i] = 1;",
			"",
			"\t// reverse(arr.begin(), arr.end());",
			"\treturn arr;",
			"}",
		],
		"description": "Converts a unsigned number to a unsigned binary representation of 64 bit",
	},
	"Binary to Number Conversion":{
		"prefix": "binaryToNum",
		"body":[
			"unsigned long long binToNum(vector<int> &bin)",
			"{",
			"\tunsigned long long cur = 1, num = 0;",
			"\tfor (int i = 0; i < 63; i++)",
			"\t{",
			"\t\tif(bin[i] == 1)",
			"\t\tnum += cur;",
			"",
			"\t\tcur *= 2;",
			"\t}",
			"",
			"\treturn num;",
			"}",
		],
		"description": "Converts a unsigned number to a unsigned binary representation of 64 bit",
	},
	"Number to vector of integer":{
		"prefix": "numToVec",
		"body": [
			"vector<int> numToVec(ll num)",
			"{",
			"\tvector<int> arr;",
			"\twhile(num > 0)",
			"\t{",
			"\t\tarr.push_back(num % 10);",
			"\t\tnum /= 10;",
			"\t}    ",
			"\treverse(arr.begin(), arr.end());",
			"\treturn arr;",
			"}",
		],
		"description": "Converts a given number to vector by its digit wise array form. Size equals total digit.",
	},
	"Binary Search on Array": {
		"prefix": "binarySearchArray",
		"body": [
			"int l = -1, r = n;",
			"while (r - l > 1) {",
			"    int m = (l + r) / 2;",
            "    if (k < a[m])",
			"    {",
            "        r = m;",
            "    }",
			"    else",
			"    {",
            "        l = m;",
            "    }",
			"}",
			"// l lower bound on k (or -1 if there is no such element)",
			"// r upper bound on k (or n if there is no such element).",
		], 
		"description": "L will be the index of the last element that is not greater than k (or -1 if there is no such element) and R will be the index of the first element larger than k (or n if there is no such element)."
	}, 
	"Binary Search on Predicate Function": {
		"prefix": "binarySearchFunction",
		"body": [
			"int l = -1, r = n;",
			"while (r - l > 1) {",
			"    int m = (l + r) / 2;",
            "    if (f(m))",
			"    {",
            "        r = m;",
            "    }",
			"    else",
			"    {",
            "        l = m;",
            "    }",
			"}",
		], 
		"description": ""
	}
}